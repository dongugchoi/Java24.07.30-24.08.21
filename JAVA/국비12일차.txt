특정 객체가 컬렉션에 들어있는지
contains(Object obj)

iterator
컬렉션 요소를 순회하여 하나씩 추출하는 방식
생성한 List,Set 객체를 통해 iterator()메서드를 통해서 객체를 생성한다.

iterator<integer> iter = list.iterator();

TreeSet
- 이진탐색트리 중에서도 성능을 향상시킨 레드블랙트리로 구현되어 있다.
- 레드블랙트리는 부모노드보다 작은값을 가지는 노드는 왼쪽  큰 값을 가지는 노드는 오른쪽 자식으로 배치하여
 데이터의 추가나 삭제 시 트리가 한쪽으로 치우쳐지지 않도록 균형을 맞추어준다.

1 ~ 50까지의 난수가 발생했을때 절반을나누고 절반을나누고 절반을 나눈다.

Map
- List, Set과 달리 Map인터페이스가 별도로 존재하며, 데이터를 List계열 컬렉션과 다르게 처리한다.
- 데이터를 Key와 Value로 구분하여 저장하는 key-value방식을 사용한다.
- index는 없지만 key를 통해서 값을 검색하기 때문에 많은 양의 데이터를 조회하는데 있어 매우
뛰어난 성능을 발휘

HashMap
- map을 구현하고 있는 자식 클래스에서 가장 많이 사용하는 구현체이다.

제네릭 사용시 주의사항
1. 제네릭 타입의 객체는 생성될 수 없다.
- 제네릭 타입 자체로 객체를 생성하는것은 불가능
T t = new T<>(); → 불가능

2. static멤버에 제네릭 타입이 올 수 없음
-static멤버는 클래스가 동일하게 공유하는 변수로서
제네릭 객체가 생성되기도 전에 이미 자료타입이
정해져있어야 하기 때문이다.

2-1 static 메서드의 반환타입으로 사용이 불가능

public static T getAge(int n){} -> X

2-2 static 메서드의 매개변수의 타입으로 사용이 불가능하다.

  public static void addAge(T n) {} 0-> X

3. 제네릭으로 배열 선언시 주의할 점
-기본적으로 제네릭 클래스 자체를 배열로 만들수는 없다.

 Sample<Integer>[] arr1 = new Sample<>[10]; -> X

또한 제네릭 타입 파라미터에 클래스가 타입으로 온다는 것은, 클래스끼리 상속을 통해 관계를 맺는
 객체 지향 프로그래밍의 다형성의 원리가 그대로 적용이 된다는 뜻이다.

중첩타입 파라미터
- 제네릭 객체를 제네릭 타입 파라미터로 받는 형식으로 표현할 수 있다.
- ArrayList자체도 하나의 타입으로서 제네릭 타입 파라미터가 될 수 있기 때문에 중첩 형식으로 사용할 수 있다.

제네릭 인터페이스
- 인터페이스를 구현(implements)한 클래스에서도
오버라이딩한 메서드를 제네릭타입에 맞춰서
똑같이 구현해야한다.

제네릭 타입 범위 한정하기
제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일 타임에 정하여 타입 예외에 대한
 안정성을 확보하는 것은 좋지만 문제는 너무 자유롭다는 점이다.

타입 한정 키워드 extends
사용법
<T extends [제한타입]>

인터페이스 타입 한정
extends 키워드 다음에 올 타입은 일반 클래스, 추상 클래스, 인터페이스 모두 올 수 있다.

다중타입한정
만일 2개 이상의 타입을 동시에 상속(구현)한 경우로 타입 제한을 하고 싶다면 &연산자를 사용하면 된다.
해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입의 대상이 되게 한다.
단, 자바에서는 다중 상속을 지원하지 않기 때문에 클래스로는 
다중 extends는 불가능하고 오로지 인터페이스로만이 가능하다.
Ex10_Generic 클래스 생성

제네릭 형변환
배열과 같은 일반적인 변수 타입과 달리 제네릭 서브 타입간에는 형변환이 불가능하다.
심지어 대입된 타입이 Object일지라도 말이다.
자연스럽게 다형성이 적용될 것이라고 생각할 수 있지만 실상 제네릭은 전달받은 타입으로만 캐스팅이 가능하다.
제네릭 타입은 상하관계가 없다.
제네릭의 타입 변수(꺾쇠 괄호)끼리는 아무라 상속 관계에 놓인다 한들 캐스팅이 불가능하다.
제네릭은 전달받은 타입만으로만 서로 캐스팅이 가능하다.

제네릭 와일드 카드
제네릭 간의 형변환을 성립되게 하기 위해서는 제네릭에서 제공하는 와일드카드 문법을 이용해야 한다.

<?> : Unbounded Wildcards(제한 없음)
타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다.
<? extends 상위타입> : Upper Bounded Wildcards(상위 클래스 제한)
타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 상위 타입의 하위 타입만 올 수 있다.
<? super 하위타입> : Lower Bounded Wildcards(하위 클래스 제한)
타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 하위 타입의 상위 타입만 올 수 있다.

람다식
JDK1.8부터 함수형 프로그래밍 '람다식(Lambda expression)'을 지원하고 있다.
람다식은 이름이 없는 익명 함수(anonymous function)를 만들기 위한 표현식을 말한다.
자바는 객체를 기반으로 프로그램을 구현하는 객체 지향 프로그램이다.
따라서 클래스를 먼저 생성하고, 클래스 안에 메서드와 객체를 만들어 사용해야 한다.
하지만 함수형 프로그래밍은 객체 지향 프로그램과 달리 함수만을 구현하고 실행할 수 있는 개발방식이다

람다식이 도입된 이유
함수형 프로그래밍 방식
자바에서는 함수형 프로그래밍 방식이 적용되지 않았다.
자바 공부할 때 함수는 어디에 만들었는가 클래스를 나누어서 작성했었다.
자바는 클래스에 함수를 정의하고 객체를 통해 호출하는 방식을 사용하고 있다.
자바 -> 함수가 독립적이지 않다. -> 반드시 객체를 만들어서 호출

람다식 문법
- 기존의 자바 문법과는 달라서 객체 지향 프로그래밍에 익숙한 개발자들은 다소 생소할 수 있다.
- 하지만 문법이 간결해지고, 원하는 결과를 쉽게 집계할 수 있어 익숙해지면 큰 장점이 있다.

기존 문법
int add(int x, int y){
	return x+y;
}

람다식 문법
  (x,y) -> {return x + y'} 
매개변수	함수 구현  ,
메서드의 이름과 반환 타입을 제거하고 화살표(->)를 이용해 구현한다.
의미를 살펴보면 두 개의 파라미터(x,y)를 사용해 더한 결과를 반환하라는 의미이다.

소괄호 생략하기
람다식 문법에서는 파라미터의 자료형을 생략할 수 있다.
파라미터가 한 개인 경우에는 소괄호도 생략할 수 있다.
그러나 파라미터가 두 개 이상일 경우에는 생략할 수 없다.
(str) -> {System.out.println(str);}
	↓ 파라미터가 1개일 때
str -> {System.out.println(str);} //소괄호 생략 가능

(x,y) -> {return x+y;}
	↓ 파라미터가 2개 이상일 때
x,y -> {return x+y;} //오류! 소괄호 생략 불가


중괄호 생략하기
함수의 반환형이 void라면 중괄호도 생략할 수 있다.
(x,y) -> {System.outprintln(x+y);}
	↓ return이 없는 경우
반환형이 있을 때 return키워드와 중괄호를 같이 생략할 수 있다.
(x,y) -> System.out.println(x+y); //중괄호 생략 가능

함수형 인터페이스
객체 지향 프로그램에서 인터페이스를 사용하려면 인터페이스를 클래스에서 구현한뒤 사용해야 한다.
람다식은 위와 같은 과정을 생략할 수 있다.
단, 람다식을 이용해 인터페이스를 사용할 경우, 인터페이스는 하나의 기능만을 정의할 수 있다.
람다식을 구현하기 위해서는 먼저 인터페이스를 만들고, 인터페이스에 람다식으로 구현할 메서드를 선언해야 한다.
오직 하나의 추상 메서드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있는데
이러한 인터페이스를 '함수형 인터페이스'라고 한다.